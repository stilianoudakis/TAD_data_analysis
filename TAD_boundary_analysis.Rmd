---
title: "TAD Boundary Analysis"
author: "Spiro Stilianoudakis"
date: "April 15, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Loading Libraries

```{r}
library(MultiAssayExperiment)
library(GenomicRanges)
library(IRanges)
library(caret)
library(data.table)
library(gbm)
library(pROC)
library(plyr)
library(dplyr)
```


# Reading in TAD data

```{r}

setwd("C:/Users/Spiro Stilianoudakis/Documents/TAD_data_analysis/data")

domains <- read.table("arrowhead_data.txt", header=T)
domains <- domains[,1:3]
head(domains)
dim(domains)
#9274   3

```

# Creating TAD boundaries

## The TAD boundary start and end coordinates were row binded into one long vector. The vector was sorted and each coordinate was flanked on each side by 500 bases for a 1kb TAD boundary bin.

```{r}

# Creating a GRanges object out of the tads

colnames(domains)[2:3] <- c("coordinate", "coordinate")
coords <- rbind.data.frame(domains[,c(1,2)],domains[,c(1,3)])

#Removing the X chromosome from the analysis
coords <- coords[-which(coords$Chromosome=="chrX"),]

#Sorting the numeric chromosome coordinates
coords <- coords[order(as.numeric(substr(coords$Chromosome,4,5)), coords$coordinate),]

#remove duplicates for coordinates that are conjoined
coords <- coords[!duplicated(coords),]
dim(coords)
#16770     2

# flanking either side of the TAD boundary by 500 bases for a 1kb centerd boundary region
coords$Chromosome <- as.character(coords$Chromosome)
bounds <- GRanges(seqnames=coords$Chromosome, ranges=IRanges(start=coords$coordinate, width=1))
bounds <- resize(bounds, 1000, fix = "center")
bounds
prop.table(table(seqnames(bounds)))

#Creating 1kb bin from min-500 to max+500 for each chromosome
#A flanked TAD boundary will be represented as these bins
bins <- rep( list(GRangesList()), length(unique(coords$Chromosome)) )

for(i in 1:length(unique(coords$Chromosome))){
seqn <- unique(coords$Chromosome)[i]

midpt <- ((min(coords$coordinate[which(coords$Chromosome==unique(coords$Chromosome)[i])])-500) + 
            (max(coords$coordinate[which(coords$Chromosome==unique(coords$Chromosome)[i])])+500))/2

bins[[i]] <- GRanges(seqnames=seqn, 
                ranges=IRanges(start=seq(min(coords$coordinate[which(coords$Chromosome==unique(coords$Chromosome)[i])])-500, 
                                         max(coords$coordinate[which(coords$Chromosome==unique(coords$Chromosome)[i])])+500,
                                         1000),
                               width=1000))

}

binslist <- GRangesList(bins)
binslist <- unlist(binslist)

#Creating an indicator variable Y that denotes whether the tad boundary overlaps the genomic bin 

y <- countOverlaps(binslist, bounds)
length(y)
table(y)
prop.table(table(y))

# adding the y vector to the bin granges
mcols(binslist)$y <- y

```

# Reading in and cleaning genomic feature data (subcompartments)

```{r}

subcompart <- read.table("GSE63525_GM12878_subcompartments.BED",header = F)
subcompart <- subcompart[,1:4]
names(subcompart) <- c("chr", "x1", "x2", "compartment")
dim(subcompart)
subcompart <- subcompart[-which(is.na(subcompart$compartment)),]
head(subcompart)
table(subcompart$compartment)
subcompart$compartment <- as.character(subcompart$compartment)

#combining compartments
subcompart$compartment[grep("A",subcompart$compartment)] <- "A"
subcompart$compartment[grep("B",subcompart$compartment)] <- "B"
table(subcompart$compartment)

```

# Creating GRanges object out of subcompartment data

```{r}

subcompart$chr <- as.character(subcompart$chr)
subcompartgr <- GRanges(seqnames = subcompart$chr, 
                        ranges = IRanges(start=subcompart$x1,
                                         end=subcompart$x2))
mcols(subcompartgr)$compartment <- subcompart$compartment

```

#Finding where the 1kb bins overlap the subcompartments and labeling the overlap as A or B

```{r}

#There are 3 scenarios of overlaps that can occur:
#i. partial
#ii. within
#iii. none
#For partial overlaps, they can either be between two (or more) subcompartments, or with only one subcompartment (i.e. there is a break between compartments)

#For Within:
subcompoverlapwithin <- findOverlaps(bounds, subcompartgr, type="within")
#there are 16558 intervals from the tad boundaries that overlab strictly within subcompartment intervals
#attaching the subcompartment info to the within overlaps
mcols(subcompoverlapwithin)$compartment <- mcols(subcompartgr)$compartment[subjectHits(subcompoverlapwithin)]
#adding percent overlap for each A abd B compartments
mcols(subcompoverlapwithin)$percentA <- ifelse(mcols(subcompoverlapwithin)$compartment=="A",1,0)
mcols(subcompoverlapwithin)$percentB <- ifelse(mcols(subcompoverlapwithin)$compartment=="B",1,0)


#For none:
subcompoverlapnone <- bounds[which(bounds %outside% subcompartgr)]
#there are 19 intervals that have no overlaps
#attaching the subcompartment info in the form of "N" for no overlap
mcols(subcompoverlapnone)$compartment <- "N"
#adding percent overlap
mcols(subcompoverlapnone)$percentA <- 0
mcols(subcompoverlapnone)$percentB <- 0


#For partial: the difference among the sets of any type of overlap and within overlaps
subcompoverlapany <- findOverlaps(bounds, subcompartgr, type="any")
#there are 16939 overlaps from the tad boundaries with subcompartment intervals
#note: there are only 16770 tad boundaries though.
#that means that there are some places where a flanked tad boundary is a part of two (or more) subcompartment intervals
#For example:
bounds[340] #covers the following two subcompartment intervals 
subcompartgr[139:140]

subcomppartial <- setdiff(subcompoverlapany,subcompoverlapwithin)

```

# Determing the percentage of partial overlaps

```{r}

#determining the frequency of partial overlaps
table(queryHits(subcomppartial))
table(table(queryHits(subcomppartial)))
#we see most partial overlaps are between two subcompartment intervals
#investigating where it is with only 1 subcompartment interval
which(table(queryHits(subcomppartial))==1)
subcomppartial[which(queryHits(subcomppartial)==5034)] #get the location of the bounds and subcompartments that overlap
#example:
bounds[5034]
subcompartgr[708]
#here we have a partial overlap with only one subcompartment interval
#since there is a break in the interval infront of subcompartgr[707]

#we need to quantify the partial overlaps in terms of a percentage

#For overlaps between two subcompartments there is a 1-to-1 relationship between percent compartment1 (A or B) overlap with percent compartment2 (A or B) overlap. That is:
# %C1 = 1-%C2

#For overlaps with 1 subcompartment interval the situation is different
#Either %C1 = ? and %C2=0 
#or
#%C1 = 0 and %C2=?

#First consider where the overlap is with only 1 subcompartment interval
oneinterval <- bounds[as.numeric(rownames(as.matrix(which(table(queryHits(subcomppartial))==1))))]
poneinterval <- findOverlapPairs(oneoverlap, subcompartgr)
poneinterval <- pintersect(poneinterval)

overlaps1 <- findOverlaps(oneoverlap, subcompartgr)
mcols(oneinterval)$compartment <- mcols(subcompartgr)$compartment[subjectHits(overlaps1)]
#attching compartment percent
mcols(oneinterval)$percentA <- ifelse(mcols(oneinterval)$compartment=="A",width(poneinterval)/width(oneinterval),0)
mcols(oneinterval)$percentB <- ifelse(mcols(oneinterval)$compartment=="B",width(poneinterval)/width(oneinterval),0)


#Now we consider the overlaps between two subcompartment intervals
twointerval <- bounds[as.numeric(rownames(as.matrix(which(table(queryHits(subcomppartial))==2))))]
ptwointerval <- findOverlapPairs(oneoverlap, subcompartgr)

pbounds <- bounds[unique(queryHits(subcomppartial))]
pbounds
psubcomp <- subcompartgr[unique(subjectHits(subcomppartial))]
psubcomp
#there are 193 unique intervals on the TAD bounds that partially overlap with 367 unique subcompartment intervals

#finding the intervals that are partially overlapped
p <- findOverlapPairs(pbounds,psubcomp)
p2 <- pintersect(p)
#attaching the subcompartment info
mcols(p2)$compartment <- mcols(subcompartgr)$compartment[subjectHits(subcomppartial)]
mcols(p2)$percentpartial <- width(p2)/width(bounds[queryHits(subcomppartial)])

#Note: all percentage of overlaps appear to be 50%

#
```



# Creating a data frame to use for logistic regression

```{r}
logitdata <- data.frame(y = mcols(binslist)$y, x = mcols(binslist)$compartment)
logitdata$x <- as.factor(logitdata$x)

#removing rows where compartment is N
logitdata <- logitdata[-which(logitdata$x=="N"),]
dim(logitdata)

```

